% layout 'default';
% title 'Rex::Commands::File - Transparent File Manipulation';

% content_for header => begin
      <meta name="description" content="With this module you can manipulate files.">
      <meta name="keywords" content="Rex, API, Documentation">
% end 


<!-- INDEX BEGIN -->
<div name="index">
<h1>TABLE OF CONTENTS</h1>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#exported_functions">EXPORTED FUNCTIONS</a></li>
</ul>


</div>
<!-- INDEX END -->

<p>
</p>
<h2>NAME</h2>
<p>Rex::Commands::File - Transparent File Manipulation</p>
<p>
</p>

<h2>DESCRIPTION</h2>
<p>With this module you can manipulate files.</p>
<p>
</p>

<h2>SYNOPSIS</h2>
<pre><code class="perl">
 task &quot;read-passwd&quot;, &quot;server01&quot;, sub {
    my $fh = file_read &quot;/etc/passwd&quot;;
    for my $line = ($fh-&gt;read_all) {
       print $line;
    }
    $fh-&gt;close;
 };</code></pre>
<pre><code class="perl">
 task &quot;read-passwd2&quot;, &quot;server01&quot;, sub {
    say cat &quot;/etc/passwd&quot;;
 };
 
 
 task &quot;write-passwd&quot;, &quot;server01&quot;, sub {
    my $fh = file_write &quot;/etc/passwd&quot;;
    $fh-&gt;write(&quot;root:*:0:0:root user:/root:/bin/sh\n&quot;);
    $fh-&gt;close;
 };
    
 delete_lines_matching &quot;/var/log/auth.log&quot;, matching =&gt; &quot;root&quot;;
 delete_lines_matching &quot;/var/log/auth.log&quot;, matching =&gt; qr{Failed};
 delete_lines_matching &quot;/var/log/auth.log&quot;, 
                        matching =&gt; &quot;root&quot;, qr{Failed}, &quot;nobody&quot;;
    
 file &quot;/path/on/the/remote/machine&quot;,
    source =&gt; &quot;/path/on/local/machine&quot;;
    
 file &quot;/path/on/the/remote/machine&quot;,
    content =&gt; &quot;foo bar&quot;;
    
 file &quot;/path/on/the/remote/machine&quot;,
    source =&gt; &quot;/path/on/local/machine&quot;,
    owner  =&gt; &quot;root&quot;,
    group  =&gt; &quot;root&quot;,
    mode   =&gt; 400,
    on_change =&gt; sub { say &quot;File was changed.&quot;; };</code></pre>
<p>
</p>

<h2>EXPORTED FUNCTIONS</h2>
<ul>
<li><strong>template($file, @params)</strong></li>


<p>Parse a template and return the content.</p>
<pre><code class="perl">
 my $content = template(&quot;/files/templates/vhosts.tpl&quot;, 
                     name =&gt; &quot;test.lan&quot;,
                     webmaster =&gt; 'webmaster@test.lan');</code></pre>

<li><strong>file($file_name, %options)</strong></li>


<p>This function is the successor of <em>install file</em>. Please use this function to upload files to you server.</p>
<pre><code class="perl">
 task &quot;prepare&quot;, &quot;server1&quot;, &quot;server2&quot;, sub {
    file &quot;/file/on/remote/machine&quot;,
       source =&gt; &quot;/file/on/local/machine&quot;;
       
    file &quot;/etc/hosts&quot;,
       content =&gt; template(&quot;templates/etc/hosts.tpl&quot;),
       owner   =&gt; &quot;user&quot;,
       group   =&gt; &quot;group&quot;,
       mode    =&gt; 700,
       on_change =&gt; sub { say &quot;Something was changed.&quot; };
        
    file &quot;/etc/motd&quot;,
       content =&gt; `fortune`;
      
    file &quot;/etc/httpd/conf/httpd.conf&quot;,
       source =&gt; &quot;/files/etc/httpd/conf/httpd.conf&quot;,
       on_change =&gt; sub { service httpd =&gt; &quot;restart&quot;; };
 };</code></pre>
<p>If <em>source</em> is relative it will search from the location of your <em>Rexfile</em> or the <em>.pm</em> file if you use Perl packages.</p>

<li><strong>file_write($file_name)</strong></li>


<p>This function opens a file for writing (it will truncate the file if it already exists). It returns a Rex::FS::File object on success.</p>
<p>On failure it will die.</p>
<pre><code class="perl">
 my $fh;
 eval {
    $fh = file_write(&quot;/etc/groups&quot;);
 };
 
 # catch an error
 if($@) {
    print &quot;An error occured. $@.\n&quot;;
 }
 
 # work with the filehandle
 $fh-&gt;write(&quot;...&quot;);
 $fh-&gt;close;</code></pre>

<li><strong>file_append($file_name)</strong></li>

<li><strong>file_read($file_name)</strong></li>


<p>This function opens a file for reading. It returns a Rex::FS::File object on success.</p>
<p>On failure it will die.</p>
<pre><code class="perl">
 my $fh;
 eval {
    $fh = read(&quot;/etc/groups&quot;);
 };
 
 # catch an error
 if($@) {
    print &quot;An error occured. $@.\n&quot;;
 }
 
 # work with the filehandle
 my $content = $fh-&gt;read_all;
 $fh-&gt;close;</code></pre>

<li><strong>cat($file_name)</strong></li>


<p>This function returns the complete content of $file_name as a string.</p>
<pre><code class="perl">
 print cat &quot;/etc/passwd&quot;;</code></pre>

<li><strong>delete_lines_matching($file, $regexp)</strong></li>


<p>Delete lines that match $regexp in $file.</p>
<pre><code class="perl">
 task &quot;clean-logs&quot;, sub {
     delete_lines_matching &quot;/var/log/auth.log&quot; =&gt; &quot;root&quot;;
 };</code></pre>

<li><strong>delete_lines_according_to($search, $file, @options)</strong></li>


<p>This is the successor of the <a href="#delete_lines_matching">delete_lines_matching()</a> function. This function also allows the usage of an on_change hook.</p>
<p>It will search for $search in $file and remove the found lines. If on_change hook is present it will execute this if the file was changed.</p>
<pre><code class="perl">
 task &quot;cleanup&quot;, &quot;server1&quot;, sub {
    delete_lines_according_to qr{^foo:}, &quot;/etc/passwd&quot;,
      on_change =&gt; sub {
         say &quot;removed user foo.&quot;;
      };
 };</code></pre>

<li><strong>append_if_no_such_line($file, $new_line, @regexp)</strong></li>


<p>Append $new_line to $file if none in @regexp is found. If no regexp is
supplied, the line is appended unless there is already an identical line
in $file.</p>
<pre><code class="perl">
 task &quot;add-group&quot;, sub {
    append_if_no_such_line &quot;/etc/groups&quot;, &quot;mygroup:*:100:myuser1,myuser2&quot;, on_change =&gt; sub { service sshd =&gt; &quot;restart&quot;; };
 };</code></pre>
<p>Since 0.42 you can use named parameters as well</p>
<pre><code class="perl">
 task &quot;add-group&quot;, sub {
    append_if_no_such_line &quot;/etc/groups&quot;,
       line   =&gt; &quot;mygroup:*:100:myuser1,myuser2&quot;,
       regexp =&gt; qr{^mygroup},
       on_change =&gt; sub {
                       say &quot;file was changed, do something.&quot;;
                    };
          
    append_if_no_such_line &quot;/etc/groups&quot;,
       line   =&gt; &quot;mygroup:*:100:myuser1,myuser2&quot;,
       regexp =&gt; [qr{^mygroup:}, qr{^ourgroup:}]; # this is an OR
 };</code></pre>

<li><strong>extract($file [, %options])</strong></li>


<p>This function extracts a file. Supported formats are .box, .tar, .tar.gz, .tgz, .tar.Z, .tar.bz2, .tbz2, .zip, .gz, .bz2, .war, .jar.</p>
<pre><code class="perl">
 task prepare =&gt; sub {
    extract &quot;/tmp/myfile.tar.gz&quot;,
      owner =&gt; &quot;root&quot;,
      group =&gt; &quot;root&quot;,
      to    =&gt; &quot;/etc&quot;;</code></pre>
<pre><code class="perl">
    extract &quot;/tmp/foo.tgz&quot;,
      type =&gt; &quot;tgz&quot;,
      mode =&gt; &quot;g+rwX&quot;;
 };
 
Can use the type=&gt; option if the file suffix has been changed. (types are tar, tgz, tbz, zip, gz, bz2)</code></pre>

<li><strong>sed($search, $replace, $file)</strong></li>


<p>Search some string in a file and replace it.</p>
<pre><code class="perl">
 task sar =&gt; sub {
    sed qr{search}, &quot;replace&quot;, &quot;/var/log/auth.log&quot;;
 };</code></pre>

</ul>




