<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <meta content="text/html; charset=utf-8" http-equiv="content-type">

      <title>Commands.pm</title>

      <meta content="width=1024, initial-scale=0.5" name="viewport">
      <link href="/rexify-website/public/images/skin/rexify.org/favicon.png" rel="shortcut icon">
      <link href="/rexify-website/public/css/skin/rexify.org/hs/tomorrow.css" rel="stylesheet">
      <link charset="utf-8" href="/rexify-website/public/css/skin/rexify.org/bootstrap.min.css?20130325" media="screen" rel="stylesheet" type="text/css">
      <link charset="utf-8" href="/rexify-website/public/css/skin/rexify.org/default.css?20140412" media="screen" rel="stylesheet" type="text/css">
      <script src="/rexify-website/public/js/skin/rexify.org/highlight.pack.js"></script>
      <meta content="" name="description">
      <meta content="" name="keywords">

   </head>
   <body>

      <div id="page">

         <div class="top_div" id="top-div">
            <h1>(R)?ex <small>Deployment &amp; Configuration Management</small></h1>
            <div id="nav-div">
               
<div class="nav_links">
  <ul>
    <li><a href="/rexify-website/">Home</a></li>
    <li><a href="/rexify-website/get/index.html">Get Rex</a></li>
    <li>
      <b class="arrow_box"></b>
      <a class="dropdown_link" href="/rexify-website/care/index.html" title="care">Care</a>
      <ul class="dropdown_menu dropdown_care">
          <li><a href="/rexify-website/care/help__r__ex.html">Help (R)?ex</a></li>
          <li><a href="/rexify-website/care/help_people_in_need.html">Help people</a></li>
      </ul>
    </li>
    <li><a href="/rexify-website/support/index.html">Support</a></li>
    <li>
      <b class="arrow_box"></b>
      <a class="dropdown_link" href="/rexify-website/docs/index.html" title="docs">Docs</a>
      <ul class="dropdown_menu dropdown_docs">
          <li><a href="/rexify-website/docs/faq/index.html">FAQ</a></li>
          <li><a href="/rexify-website/docs/guides/index.html">Guides</a></li>
          <li><a href="/rexify-website/docs/rex_book/index.html">Rex Book (work in progress)</a></li>
          <li><a href="/rexify-website/docs/other/index.html">Other</a></li>
          <li><a href="/rexify-website/docs/release_notes/index.html">Release notes</a></li>
            <li class="divider"></li>
          <li><a href="/rexify-website/docs/api/index.html">API</a></li>
      </ul>
    </li>
  </ul>
</div>

            </div>
            </div>
         </div>

         <div id="widgets_container">
            <div id="widgets">
               <h2>Conferences</h2>
                 <div class="news_widget">
                    <div class="news_date">2016-06-21</div>
                    <div class="news_content"><a href="http://preaction.me/">Doug Bell (preaction)</a> from <a href="http://chicago.pm.org/">Chicago.pm</a> will give an <a href="http://www.yapcna.org/yn2016/talk/6549">Introduction to Rex</a> talk at <a href="http://www.yapcna.org/yn2016/">YAPC::NA 2016</a>.</div>
                 </div>

               <h2>Need Help?</h2>
               <p>Rex is a pure open source project, you can find community support in the following places:</p>
               <ul>
                  <li>IRC: <a href="irc://irc.freenode.net/rex">#rex on irc.freenode.net</a></li>
                  <li>Groups: <a href="https://groups.google.com/group/rex-users/">Rex Users</a></li>
                  <li>Serverfault: <a href="http://serverfault.com/questions/tagged/rex">Tag with <i>rex</i></a></li>
                  <li>Issues: <a href="https://github.com/RexOps/Rex/issues">on GitHub</a></li>
                  <li>Feature: you miss a <a href="/rexify-website/feature.html">feature</a>?</li>
               </ul>
               <p><a href="/rexify-website/support/index.html">Professional support</a> is also available.</p>
            </div>
         </div> <!-- widgets -->

         <div id="content_container">
            <div id="content">
              




<p>
» <a href="/rexify-website/index.html">Home</a>
» <a href="/rexify-website/docs/index.html">Docs</a>
» <a href="/rexify-website/docs/api/index.html">Api</a>
» <a href="/rexify-website/docs/api/1.4/index.html">1.4</a>
» <a href="/rexify-website/docs/api/1.4/rex/index.html">Rex</a>
» <a href="/rexify-website/docs/api/1.4/rex/commands.pm.html">Commands.pm</a>
</p>

              
              <h1>Commands.pm</h1>
              <ul>
<li><a href="#NAME">NAME</a></li>
<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
<li><a href="#SYNOPSIS">SYNOPSIS</a></li>
<li><a href="#COMMANDLIST">COMMANDLIST</a></li>
<li><a href="#EXPORTED-FUNCTIONS">EXPORTED FUNCTIONS</a>
<ul>
<li><a href="#no_ssh-task-">no_ssh([$task])</a></li>
<li><a href="#task-name-servers-funcref-">task($name [, @servers], $funcref)</a></li>
<li><a href="#desc-description-">desc($description)</a></li>
<li><a href="#group-name-servers-">group($name, @servers)</a></li>
<li><a href="#batch-name-tasks-">batch($name, @tasks)</a></li>
<li><a href="#user-user-">user($user)</a></li>
<li><a href="#password-password-">password($password)</a></li>
<li><a href="#auth-for-entity-data-">auth(for =&gt; $entity, %data)</a></li>
<li><a href="#port-port-">port($port)</a></li>
<li><a href="#sudo_password-password-">sudo_password($password)</a></li>
<li><a href="#timeout-seconds-">timeout($seconds)</a></li>
<li><a href="#max_connect_retries-count-">max_connect_retries($count)</a></li>
<li><a href="#get_random-count-chars-">get_random($count, @chars)</a></li>
<li><a href="#do_task-task-">do_task($task)</a></li>
<li><a href="#run_task-task_name-option-">run_task($task_name, %option)</a></li>
<li><a href="#run_batch-batch_name-option-">run_batch($batch_name, %option)</a></li>
<li><a href="#public_key-key-">public_key($key)</a></li>
<li><a href="#private_key-key-">private_key($key)</a></li>
<li><a href="#pass_auth">pass_auth</a></li>
<li><a href="#key_auth">key_auth</a></li>
<li><a href="#krb5_auth">krb5_auth</a></li>
<li><a href="#parallelism-count-">parallelism($count)</a></li>
<li><a href="#proxy_command-cmd-">proxy_command($cmd)</a></li>
<li><a href="#set_distributor-distributor-">set_distributor($distributor)</a></li>
<li><a href="#template_function-sub-...-">template_function(sub { ... })</a></li>
<li><a href="#logging">logging</a></li>
<li><a href="#needs-package-tasks-">needs($package [, @tasks])</a></li>
<li><a href="#include-Module::Name">include Module::Name</a></li>
<li><a href="#environment-name-code-">environment($name =&gt; $code)</a></li>
<li><a href="#LOCAL-">LOCAL(&amp;)</a></li>
<li><a href="#path-path-">path(@path)</a></li>
<li><a href="#set-key-value-">set($key, $value)</a></li>
<li><a href="#get-key-value-">get($key, $value)</a></li>
<li><a href="#before-task-sub-">before($task =&gt; sub {})</a></li>
<li><a href="#after-task-sub-">after($task =&gt; sub {})</a></li>
<li><a href="#around-task-sub-">around($task =&gt; sub {})</a></li>
<li><a href="#before_task_start-task-sub-">before_task_start($task =&gt; sub {})</a></li>
<li><a href="#after_task_finished-task-sub-">after_task_finished($task =&gt; sub {})</a></li>
<li><a href="#logformat-format-">logformat($format)</a></li>
<li><a href="#connection">connection</a></li>
<li><a href="#cache">cache</a></li>
<li><a href="#profiler">profiler</a></li>
<li><a href="#report-switch-type-">report($switch, $type)</a></li>
<li><a href="#source_global_profile-0-1-">source_global_profile(0|1)</a></li>
<li><a href="#last_command_output">last_command_output</a></li>
<li><a href="#case-compare-option-">case($compare, $option)</a></li>
<li><a href="#set_executor_for-type-executor-">set_executor_for($type, $executor)</a></li>
<li><a href="#tmp_dir-tmp_dir-">tmp_dir($tmp_dir)</a></li>
<li><a href="#inspect-varRef-">inspect($varRef)</a></li>
<li><a href="#sayformat-format-">sayformat($format)</a></li>
</ul></li>
</ul>

<h1 id="name">NAME</h1>

<p>Rex::Commands - All the basic commands</p>

<h1 id="description">DESCRIPTION</h1>

<p>This module is the core commands module.</p>

<h1 id="synopsis">SYNOPSIS</h1>

<pre><code> desc &quot;Task description&quot;;

 task &quot;taskname&quot;, sub { ... };
 task &quot;taskname&quot;, &quot;server1&quot;, ..., &quot;server20&quot;, sub { ... };

 group &quot;group&quot; =&gt; &quot;server1&quot;, &quot;server2&quot;, ...;

 user &quot;user&quot;;

 password &quot;password&quot;;

 environment live =&gt; sub {
   user &quot;root&quot;;
   password &quot;foobar&quot;;
   pass_auth;
   group frontend =&gt; &quot;www01&quot;, &quot;www02&quot;;
 };
</code></pre>

<h1 id="commandlist">COMMANDLIST</h1>

<ul>
<li><p>Augeas config file management library <span>Rex::Commands::Augeas</span></p></li>
<li><p>Cloud Management <span>Rex::Commands::Cloud</span></p></li>
<li><p>Cron Management <span>Rex::Commands::Cron</span></p></li>
<li><p>Database Commands <span>Rex::Commands::DB</span></p></li>
<li><p>SCP Up- and Download <span>Rex::Commands::Upload</span>, <span>Rex::Commands::Download</span></p></li>
<li><p>File Manipulation <span>Rex::Commands::File</span></p></li>
<li><p>Filesystem Manipulation <span>Rex::Commands::Fs</span></p></li>
<li><p>Information Gathering <span>Rex::Commands::Gather</span></p></li>
<li><p>Manipulation of /etc/hosts <span>Rex::Commands::Host</span></p></li>
<li><p>Get an inventory of your Hardware <span>Rex::Commands::Inventory</span></p></li>
<li><p>Manage your iptables rules <span>Rex::Commands::Iptables</span></p></li>
<li><p>Kernel Commands <span>Rex::Commands::Kernel</span></p></li>
<li><p>LVM Commands <span>Rex::Commands::LVM</span></p></li>
<li><p>MD5 checksums <span>Rex::Commands::MD5</span></p></li>
<li><p>Network commands <span>Rex::Commands::Network</span></p></li>
<li><p>Notify resources to execute <span>Rex::Commands::Notify</span></p></li>
<li><p>Package Commands <span>Rex::Commands::Pkg</span></p></li>
<li><p>Partition your storage device(s) <span>Rex::Commands::Partition</span></p></li>
<li><p>Configure packages (via debconf) <span>Rex::Commands::PkgConf</span></p></li>
<li><p>Process Management <span>Rex::Commands::Process</span></p></li>
<li><p>Rsync Files <span>Rex::Commands::Rsync</span></p></li>
<li><p>Run Remote Commands <span>Rex::Commands::Run</span></p></li>
<li><p>Source control via Subversion/Git <span>Rex::Commands::SCM</span></p></li>
<li><p>Manage System Services (sysvinit) <span>Rex::Commands::Service</span></p></li>
<li><p>Simple TCP/alive checks <span>Rex::Commands::SimpleCheck</span></p></li>
<li><p>Sync directories <span>Rex::Commands::Sync</span></p></li>
<li><p>Sysctl Commands <span>Rex::Commands::Sysctl</span></p></li>
<li><p>Live Tail files <span>Rex::Commands::Tail</span></p></li>
<li><p>Upload local file to remote server <span>Rex::Commands::Upload</span></p></li>
<li><p>Manage user and group accounts <span>Rex::Commands::User</span></p></li>
<li><p>Manage your virtual environments <span>Rex::Commands::Virtualization</span></p></li>
</ul>

<h1 id="exportedfunctions">EXPORTED FUNCTIONS</h1>

<h2 id="no_sshtask">no_ssh([$task])</h2>

<p>Disable ssh for all tasks or a specified task.</p>

<p>If you want to disable ssh connection for your complete tasks (for example if you only want to use libVirt) put this in the main section of your Rexfile.</p>

<pre><code> no_ssh;
</code></pre>

<p>If you want to disable ssh connection for a given task, put <em>no_ssh</em> in front of the task definition.</p>

<pre><code> no_ssh task &quot;mytask&quot;, &quot;myserver&quot;, sub {
   say &quot;Do something without a ssh connection&quot;;
 };
</code></pre>

<h2 id="tasknameserversfuncref">task($name [, @servers], $funcref)</h2>

<p>This function will create a new task.</p>

<p>Create a local task (a server independent task) <br>
     task &quot;mytask&quot;, sub {
       say &quot;Do something&quot;;
     };</p>

<p>If you call this task with (R)?ex it will run on your local machine. You can explicit run this task on other machines if you specify the <em>-H</em> command line parameter.</p>

<p>Create a server bound task. <br>
     task &quot;mytask&quot;, &quot;server1&quot;, sub {
       say &quot;Do something&quot;;
     };</p>

<p>You can also specify more than one server.</p>

<pre><code> task &quot;mytask&quot;, &quot;server1&quot;, &quot;server2&quot;, &quot;server3&quot;, sub {
   say &quot;Do something&quot;;
 };
</code></pre>

<p>Or you can use some expressions to define more than one server.</p>

<pre><code> task &quot;mytask&quot;, &quot;server[1..3]&quot;, sub {
   say &quot;Do something&quot;;
 };
</code></pre>

<p>If you want, you can overwrite the servers with the <em>-H</em> command line parameter.</p>

<p>Create a group bound task. <br>
You can define server groups with the <em>group</em> function.</p>

<pre><code> group &quot;allserver&quot; =&gt; &quot;server[1..3]&quot;, &quot;workstation[1..10]&quot;;

 task &quot;mytask&quot;, group =&gt; &quot;allserver&quot;, sub {
   say &quot;Do something&quot;;
 };
</code></pre>

<h2 id="descdescription">desc($description)</h2>

<p>Set the description of a task.</p>

<pre><code> desc &quot;This is a task description of the following task&quot;;
 task &quot;mytask&quot;, sub {
   say &quot;Do something&quot;;
 }
</code></pre>

<h2 id="groupnameservers">group($name, @servers)</h2>

<p>With this function you can group servers, so that you don&#39;t need to write too much ;-)</p>

<pre><code> group &quot;servergroup&quot;, &quot;www1&quot;, &quot;www2&quot;, &quot;www3&quot;, &quot;memcache01&quot;, &quot;memcache02&quot;, &quot;memcache03&quot;;
</code></pre>

<p>Or with the expression syntax:</p>

<pre><code> group &quot;servergroup&quot;, &quot;www[1..3]&quot;, &quot;memcache[01..03]&quot;;
</code></pre>

<p>You can also specify server options after a server name with a hash reference:</p>

<pre><code> group &quot;servergroup&quot;, &quot;www1&quot; =&gt; { user =&gt; &quot;other&quot; }, &quot;www2&quot;;
</code></pre>

<p>These expressions are allowed:</p>

<ul>
<li><p>\d+..\d+ (range)</p>

<p>The first number is the start and the second number is the end for numbering the servers.</p>

<pre><code> group &quot;name&quot;, &quot;www[1..3]&quot;; # www1, www2, www3
</code></pre></li>
<li><p>\d+..\d+/\d+ (range with step)</p>

<p>Just like the range notation, but with an additional &quot;step&quot; defined. If step is omitted, it defaults to 1 (i.e. it behaves like a simple range expression).</p>

<pre><code> group &quot;name&quot;, &quot;www[1..5/2]&quot;;      # www1, www3, www5
 group &quot;name&quot;, &quot;www[111..133/11]&quot;; # www111, www122, www133
</code></pre></li>
<li><p>\d+,\d+,\d+ (list)</p>

<p>With this variant you can define fixed values.</p>

<pre><code> group &quot;name&quot;, &quot;www[1,3,7,01]&quot;; # www1, www3, www7, www01
</code></pre></li>
<li><p>Mixed list, range and range with step</p>

<p>You can mix the three variants above</p>

<pre><code> www[1..3,5,9..21/3]; # www1, www2, www3, www5, www9, www12, www15, www18, www21
</code></pre></li>
</ul>

<h2 id="batchnametasks">batch($name, @tasks)</h2>

<p>With the batch function you can call tasks in a batch.</p>

<pre><code> batch &quot;name&quot;, &quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;;
</code></pre>

<p>And call it with the <em>-b</em> console parameter. <em>rex -b name</em></p>

<h2 id="useruser">user($user)</h2>

<p>Set the user for the ssh connection.</p>

<h2 id="passwordpassword">password($password)</h2>

<p>Set the password for the ssh connection (or for the private key file).</p>

<h2 id="authforgtentitydata">auth(for =&gt; $entity, %data)</h2>

<p>With this function you can modify/set special authentication parameters for tasks and groups. If you want to modify a group&#39;s authentication you first have to create it. (Place the auth command after the group.)</p>

<p>If you want to set special login information for a group you have to activate that feature first.</p>

<pre><code> use Rex -feature =&gt; 0.31; # activate setting auth for a group

 # auth for groups

 group frontends =&gt; &quot;web[01..10]&quot;;
 group backends =&gt; &quot;be[01..05]&quot;;

 auth for =&gt; &quot;frontends&quot; =&gt;
            user =&gt; &quot;root&quot;,
            password =&gt; &quot;foobar&quot;;

 auth for =&gt; &quot;backends&quot; =&gt;
            user =&gt; &quot;admin&quot;,
            private_key =&gt; &quot;/path/to/id_rsa&quot;,
            public_key =&gt; &quot;/path/to/id_rsa.pub&quot;,
            sudo =&gt; TRUE;

 # auth for tasks

 task &quot;prepare&quot;, group =&gt; [&quot;frontends&quot;, &quot;backends&quot;], sub {
   # do something
 };

 auth for =&gt; &quot;prepare&quot; =&gt;
            user =&gt; &quot;root&quot;;

 # auth for multiple tasks with regular expression

 task &quot;step_1&quot;, sub {
  # do something
 };

 task &quot;step_2&quot;, sub {
  # do something
 };

 auth for =&gt; qr/step/ =&gt;
   user     =&gt; $user,
   password =&gt; $password;

 # fallback auth
 auth fallback =&gt; {
   user        =&gt; &quot;fallback_user1&quot;,
   password    =&gt; &quot;fallback_pw1&quot;,
   public_key  =&gt; &quot;&quot;,
   private_key =&gt; &quot;&quot;,
 }, {
   user        =&gt; &quot;fallback_user2&quot;,
   password    =&gt; &quot;fallback_pw2&quot;,
   public_key  =&gt; &quot;keys/public.key&quot;,
   private_key =&gt; &quot;keys/private.key&quot;,
   sudo        =&gt; TRUE,
 };
</code></pre>

<h2 id="portport">port($port)</h2>

<p>Set the port where the ssh server is listening.</p>

<h2 id="sudo_passwordpassword">sudo_password($password)</h2>

<p>Set the password for the sudo command.</p>

<h2 id="timeoutseconds">timeout($seconds)</h2>

<p>Set the timeout for the ssh connection and other network related stuff.</p>

<h2 id="max_connect_retriescount">max_connect_retries($count)</h2>

<p>Set the maximum number of connection retries.</p>

<h2 id="get_randomcountchars">get_random($count, @chars)</h2>

<p>Returns a random string of $count characters on the basis of @chars.</p>

<pre><code> my $rnd = get_random(8, &#39;a&#39; .. &#39;z&#39;);
</code></pre>

<h2 id="do_tasktask">do_task($task)</h2>

<p>Call $task from another task. It will establish a new connection to the server defined in $task and then execute $task there.</p>

<pre><code> task &quot;task1&quot;, &quot;server1&quot;, sub {
   say &quot;Running on server1&quot;;
   do_task &quot;task2&quot;;
 };

 task &quot;task2&quot;, &quot;server2&quot;, sub {
   say &quot;Running on server2&quot;;
 };
</code></pre>

<p>You may also use an arrayRef for $task if you want to call multiple tasks.</p>

<pre><code> do_task [ qw/task1 task2 task3/ ];
</code></pre>

<h2 id="run_tasktask_nameoption">run_task($task_name, %option)</h2>

<p>Run a task on a given host.</p>

<pre><code> my $return = run_task &quot;taskname&quot;, on =&gt; &quot;192.168.3.56&quot;;
</code></pre>

<p>Do something on server5 if memory is less than 100 MB free on server3.</p>

<pre><code> task &quot;prepare&quot;, &quot;server5&quot;, sub {
   my $free_mem = run_task &quot;get_free_mem&quot;, on =&gt; &quot;server3&quot;;
   if($free_mem &lt; 100) {
     say &quot;Less than 100 MB free mem on server3&quot;;
     # create a new server instance on server5 to unload server3
   }
 };

 task &quot;get_free_mem&quot;, sub {
    return memory-&gt;{free};
 };
</code></pre>

<p>If called without a hostname the task is run localy.</p>

<pre><code> # this task will run on server5
 task &quot;prepare&quot;, &quot;server5&quot;, sub {
   # this will call task check_something. but this task will run on localhost.
   my $check = run_task &quot;check_something&quot;;
 }

 task &quot;check_something&quot;, &quot;server4&quot;, sub {
   return &quot;foo&quot;;
 };
</code></pre>

<p>If you want to add custom parameters for the task you can do it this way.</p>

<pre><code> task &quot;prepare&quot;, &quot;server5&quot;, sub {
  run_task &quot;check_something&quot;, on =&gt; &quot;foo&quot;, params =&gt; { param1 =&gt; &quot;value1&quot;, param2 =&gt; &quot;value2&quot; };
 };
</code></pre>

<h2 id="run_batchbatch_nameoption">run_batch($batch_name, %option)</h2>

<p>Run a batch on a given host.</p>

<pre><code> my @return = run_batch &quot;batchname&quot;, on =&gt; &quot;192.168.3.56&quot;;
</code></pre>

<p>It calls internally run_task, and passes it any option given.</p>

<h2 id="public_keykey">public_key($key)</h2>

<p>Set the public key.</p>

<h2 id="private_keykey">private_key($key)</h2>

<p>Set the private key.</p>

<h2 id="pass_auth">pass_auth</h2>

<p>If you want to use password authentication, then you need to call <em>pass_auth</em>.</p>

<pre><code> user &quot;root&quot;;
 password &quot;root&quot;;

 pass_auth;
</code></pre>

<h2 id="key_auth">key_auth</h2>

<p>If you want to use pubkey authentication, then you need to call <em>key_auth</em>.</p>

<pre><code> user &quot;bob&quot;;
 private_key &quot;/home/bob/.ssh/id_rsa&quot;; # passphrase-less key
 public_key &quot;/home/bob/.ssh/id_rsa.pub&quot;;

 key_auth;
</code></pre>

<h2 id="krb5_auth">krb5_auth</h2>

<p>If you want to use kerberos authentication, then you need to call <em>krb5_auth</em>. This authentication mechanism is only available if you use Net::OpenSSH.</p>

<pre><code> set connection =&gt; &quot;OpenSSH&quot;;
 user &quot;root&quot;;
 krb5_auth;
</code></pre>

<h2 id="parallelismcount">parallelism($count)</h2>

<p>Will execute the tasks in parallel on the given servers. $count is the thread count to be used:</p>

<pre><code> parallelism &#39;2&#39;; # set parallelism to 2
</code></pre>

<p>Alternatively, the following notation can be used to set thread count more dynamically:</p>

<pre><code> parallelism &#39;max&#39;;     # set parallelism to the number of servers a task is asked to run on
 parallelism &#39;max/3&#39;;   # set parallelism to 1/3 of the number of servers
 parallelism &#39;max 10%&#39;; # set parallelism to 10% of the number of servers
</code></pre>

<p>If an unrecognized value is passed, or the calculated thread count would be less than 1, Rex falls back to use a single thread.</p>

<h2 id="proxy_commandcmd">proxy_command($cmd)</h2>

<p>Set a proxy command to use for the connection. This is only possible with OpenSSH connection method.</p>

<pre><code> set connection =&gt; &quot;OpenSSH&quot;;
 proxy_command &quot;ssh user@jumphost nc %h %p 2&gt;/dev/null&quot;;
</code></pre>

<h2 id="set_distributordistributor">set_distributor($distributor)</h2>

<p>This sets the task distribution module. Default is &quot;Base&quot;.</p>

<p>Possible values are: Base, Gearman, Parallel_ForkManager</p>

<h2 id="template_functionsub...">template_function(sub { ... })</h2>

<p>This function sets the template processing function. So it is possible to change the template engine. For example to Template::Toolkit.</p>

<h2 id="logging">logging</h2>

<p>With this function you can define the logging behaviour of (R)?ex.</p>

<p>Logging to a file <br>
     logging to_file =&gt; &quot;rex.log&quot;;</p>

<p>Logging to syslog <br>
     logging to_syslog =&gt; $facility;</p>

<h2 id="needspackagetasks">needs($package [, @tasks])</h2>

<p>With <em>needs</em> you can define dependencies between tasks. The &quot;needed&quot; tasks will be called with the same server configuration as the calling task.</p>

<p><em>needs</em> will not execute before, around and after hooks.</p>

<p>Depend on all tasks in a given package. <br>
Depend on all tasks in the package MyPkg. All tasks will be called with the server <em>server1</em>.</p>

<pre><code> task &quot;mytask&quot;, &quot;server1&quot;, sub {
   needs MyPkg;
 };
</code></pre>

<p>Depend on a single task in a given package. <br>
Depend on the <em>uname</em> task in the package MyPkg. The <em>uname</em> task will be called with the server <em>server1</em>.</p>

<pre><code> task &quot;mytask&quot;, &quot;server1&quot;, sub {
   needs MyPkg &quot;uname&quot;;
 };
</code></pre>

<p>To call tasks defined in the Rexfile from within a module <br>
     task &quot;mytask&quot;, &quot;server1&quot;, sub {
       needs main &quot;uname&quot;;
     };</p>

<h2 id="includemodule::name">include Module::Name</h2>

<p>Include a module without registering its tasks.</p>

<pre><code>  include qw/
    Module::One
    Module::Two
  /;
</code></pre>

<h2 id="environmentnamegtcode">environment($name =&gt; $code)</h2>

<p>Define an environment. With environments one can use the same task for different hosts. For example if you want to use the same task on your integration-, test- and production servers.</p>

<pre><code> # define default user/password
 user &quot;root&quot;;
 password &quot;foobar&quot;;
 pass_auth;

 # define default frontend group containing only testwww01.
 group frontend =&gt; &quot;testwww01&quot;;

 # define live environment, with different user/password
 # and a frontend server group containing www01, www02 and www03.
 environment live =&gt; sub {
   user &quot;root&quot;;
   password &quot;livefoo&quot;;
   pass_auth;

   group frontend =&gt; &quot;www01&quot;, &quot;www02&quot;, &quot;www03&quot;;
 };

 # define stage environment with default user and password. but with
 # a own frontend group containing only stagewww01.
 environment stage =&gt; sub {
   group frontend =&gt; &quot;stagewww01&quot;;
 };

 task &quot;prepare&quot;, group =&gt; &quot;frontend&quot;, sub {
    say run &quot;hostname&quot;;
 };
</code></pre>

<p>Calling this task <em>rex prepare</em> will execute on testwww01. Calling this task with <em>rex -E live prepare</em> will execute on www01, www02, www03. Calling this task <em>rex -E stage prepare</em> will execute on stagewww01.</p>

<p>You can call the function within a task to get the current environment.</p>

<pre><code> task &quot;prepare&quot;, group =&gt; &quot;frontend&quot;, sub {
   if(environment() eq &quot;dev&quot;) {
     say &quot;i&#39;m in the dev environment&quot;;
   }
 };
</code></pre>

<p>If no <em>-E</em> option is passed on the command line, the default environment (named &#39;default&#39;) will be used.</p>

<h2 id="local">LOCAL(&amp;)</h2>

<p>With the LOCAL function you can do local commands within a task that is defined to work on remote servers.</p>

<pre><code> task &quot;mytask&quot;, &quot;server1&quot;, &quot;server2&quot;, sub {
    # this will call &#39;uptime&#39; on the servers &#39;server1&#39; and &#39;server2&#39;
    say run &quot;uptime&quot;;

    # this will call &#39;uptime&#39; on the local machine.
    LOCAL {
      say run &quot;uptime&quot;;
    };
 };
</code></pre>

<h2 id="pathpath">path(@path)</h2>

<p>Set the execution path for all commands.</p>

<pre><code> path &quot;/bin&quot;, &quot;/sbin&quot;, &quot;/usr/bin&quot;, &quot;/usr/sbin&quot;, &quot;/usr/pkg/bin&quot;, &quot;/usr/pkg/sbin&quot;;
</code></pre>

<h2 id="setkeyvalue">set($key, $value)</h2>

<p>Set a configuration parameter. These variables can be used in templates as well.</p>

<pre><code> set database =&gt; &quot;db01&quot;;

 task &quot;prepare&quot;, sub {
   my $db = get &quot;database&quot;;
 };
</code></pre>

<p>Or in a template</p>

<pre><code> DB: &lt;%= $::database %&gt;
</code></pre>

<p>The following list of configuration parameters are Rex specific:</p>

<h2 id="getkeyvalue">get($key, $value)</h2>

<p>Get a configuration parameter.</p>

<pre><code> set database =&gt; &quot;db01&quot;;

 task &quot;prepare&quot;, sub {
   my $db = get &quot;database&quot;;
 };
</code></pre>

<p>Or in a template</p>

<pre><code> DB: &lt;%= $::database %&gt;
</code></pre>

<h2 id="beforetaskgtsub">before($task =&gt; sub {})</h2>

<p>Run code before executing the specified task. The special taskname &#39;ALL&#39; can be used to run code before all tasks. If called repeatedly, each sub will be appended to a list of &#39;before&#39; functions.</p>

<p>In this hook you can overwrite the server to which the task will connect to. The second argument is a reference to the server object that will be used for the connection.</p>

<p>Note: must come after the definition of the specified task</p>

<pre><code> before mytask =&gt; sub {
  my ($server, $server_ref, $cli_args) = @_;
  run &quot;vzctl start vm$server&quot;;
 };
</code></pre>

<h2 id="aftertaskgtsub">after($task =&gt; sub {})</h2>

<p>Run code after the task is finished. The special taskname &#39;ALL&#39; can be used to run code after all tasks. If called repeatedly, each sub will be appended to a list of &#39;after&#39; functions.</p>

<p>Note: must come after the definition of the specified task</p>

<pre><code> after mytask =&gt; sub {
  my ($server, $failed, $cli_args) = @_;
  if($failed) { say &quot;Connection to $server failed.&quot;; }

  run &quot;vzctl stop vm$server&quot;;
 };
</code></pre>

<h2 id="aroundtaskgtsub">around($task =&gt; sub {})</h2>

<p>Run code before and after the task is finished. The special taskname &#39;ALL&#39; can be used to run code around all tasks. If called repeatedly, each sub will be appended to a list of &#39;around&#39; functions.</p>

<p>In this hook you can overwrite the server to which the task will connect to. The second argument is a reference to the server object that will be used for the connection.</p>

<p>Note: must come after the definition of the specified task</p>

<pre><code> around mytask =&gt; sub {
  my ($server, $server_ref, $cli_args, $position) = @_;

  unless($position) {
    say &quot;Before Task\n&quot;;
  }
  else {
    say &quot;After Task\n&quot;;
  }
 };
</code></pre>

<h2 id="before_task_starttaskgtsub">before_task_start($task =&gt; sub {})</h2>

<p>Run code before executing the specified task. This gets executed only once for a task. The special taskname &#39;ALL&#39; can be used to run code before all tasks. If called repeatedly, each sub will be appended to a list of &#39;before_task_start&#39; functions.</p>

<p>Note: must come after the definition of the specified task</p>

<pre><code> before_task_start mytask =&gt; sub {
   # do some things
 };
</code></pre>

<h2 id="after_task_finishedtaskgtsub">after_task_finished($task =&gt; sub {})</h2>

<p>Run code after the task is finished (and after the ssh connection is terminated). This gets executed only once for a task. The special taskname &#39;ALL&#39; can be used to run code before all tasks. If called repeatedly, each sub will be appended to a list of &#39;after_task_finished&#39; functions.</p>

<p>Note: must come after the definition of the specified task</p>

<pre><code> after_task_finished mytask =&gt; sub {
   # do some things
 };
</code></pre>

<h2 id="logformatformat">logformat($format)</h2>

<p>You can define the logging format with the following parameters.</p>

<p>%D - Appends the current date yyyy-mm-dd HH:mm:ss</p>

<p>%h - The target host</p>

<p>%p - The pid of the running process</p>

<p>%l - Loglevel (INFO or DEBUG)</p>

<p>%s - The Logstring</p>

<p>Default is: [%D] %l - %s</p>

<h2 id="connection">connection</h2>

<p>This function returns the current connection object.</p>

<pre><code> task &quot;foo&quot;, group =&gt; &quot;baz&quot;, sub {
   say &quot;Current Server: &quot; . connection-&gt;server;
 };
</code></pre>

<h2 id="cache">cache</h2>

<p>This function returns the current cache object.</p>

<h2 id="profiler">profiler</h2>

<p>Returns the profiler object for the current connection.</p>

<h2 id="reportswitchtype">report($switch, $type)</h2>

<p>This function will initialize the reporting.</p>

<pre><code> report -on =&gt; &quot;YAML&quot;;
</code></pre>

<h2 id="source_global_profile01">source_global_profile(0|1)</h2>

<p>If this option is set, every run() command will first source /etc/profile before getting executed.</p>

<h2 id="last_command_output">last_command_output</h2>

<p>This function returns the output of the last &quot;run&quot; command.</p>

<p>On a debian system this example will return the output of <em>apt-get install foobar</em>.</p>

<pre><code> task &quot;mytask&quot;, &quot;myserver&quot;, sub {
   install &quot;foobar&quot;;
   say last_command_output();
 };
</code></pre>

<h2 id="casecompareoption">case($compare, $option)</h2>

<p>This is a function to compare a string with some given options.</p>

<pre><code> task &quot;mytask&quot;, &quot;myserver&quot;, sub {
   my $ntp_service = case operating_sytem, {
                 Debian  =&gt; &quot;ntp&quot;,
                 default =&gt; &quot;ntpd&quot;,
               };

   my $ntp_service = case operating_sytem, {
                 qr{debian}i =&gt; &quot;ntp&quot;,
                 default    =&gt; &quot;ntpd&quot;,
               };

   my $ntp_service = case operating_sytem, {
                 qr{debian}i =&gt; &quot;ntp&quot;,
                 default    =&gt; sub { return &quot;foo&quot;; },
               };
 };
</code></pre>

<h2 id="set_executor_fortypeexecutor">set_executor_for($type, $executor)</h2>

<p>Set the executor for a special type. This is primary used for the upload_and_run helper function.</p>

<pre><code> set_executor_for perl =&gt; &quot;/opt/local/bin/perl&quot;;
</code></pre>

<h2 id="tmp_dirtmp_dir">tmp_dir($tmp_dir)</h2>

<p>Set the tmp directory on the remote host to store temporary files.</p>

<h2 id="inspectvarref">inspect($varRef)</h2>

<p>This function dumps the contents of a variable to STDOUT.</p>

<p>task &quot;mytask&quot;, &quot;myserver&quot;, sub { my $myvar = { name =&gt; &quot;foo&quot;, sys =&gt; &quot;bar&quot;, };</p>

<pre><code>  inspect $myvar;
};
</code></pre>

<h2 id="sayformatformat">sayformat($format)</h2>

<p>You can define the format of the say() function.</p>

<p>%D - The current date yyyy-mm-dd HH:mm:ss</p>

<p>%h - The target host</p>

<p>%p - The pid of the running process</p>

<p>%s - The Logstring</p>

<p>You can also define the following values:</p>

<p>default - the default behaviour.</p>

<p>asis - will print every single parameter in its own line. This is useful if you want to print the output of a command.</p>



            </div>
         </div> <!-- content -->

       <!-- page -->


     <a href="http://github.com/RexOps/Rex"><img alt="Fork me on GitHub" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" style="position: absolute; top: 0; right: 0; border: 0;"></a>

   <div class="clearfix"></div>
   <div class="bottom_bar">
      <a href="https://groups.google.com/group/rex-users/">Google Group</a> / <a href="http://twitter.com/RexOps">Twitter</a> / <a href="https://github.com/RexOps/Rex">GitHub</a> / <a href="http://www.freelists.org/list/rex-users">Mailinglist</a> / <a href="irc://irc.freenode.net/rex">irc.freenode.net #rex</a><span id="syntax_high" style="display: none;"> / <a href="#" id="link_syntax_high">Enable Syntax Highlighting</a></span>   -.ô.-   <a href="http://www.disclaimer.de/disclaimer.htm" target="_blank">Disclaimer</a>
   </div>

   <script charset="utf-8" src="/rexify-website/public/js/skin/rexify.org/jquery.js" type="text/javascript"></script>
   <script charset="utf-8" src="/rexify-website/public/js/skin/rexify.org/bootstrap.min.js" type="text/javascript"></script>
   <script charset="utf-8" src="/rexify-website/public/js/skin/rexify.org/menu.js" type="text/javascript"></script>
   <script charset="utf-8" src="/rexify-website/public/js/skin/rexify.org/ZeroClipboard.min.js" type="text/javascript"></script>

   <script>
      var client = new ZeroClipboard($(".copy-button"), { moviePath: "/public/js/skin/rexify.org/ZeroClipboard.swf"});
   </script>

   <script>
      if($(window).width() <= 1100) {
         // hide API link
         $("#li_api").hide();
      }
      $(window).on('resize', function() {
       if($(window).width() <= 1100) {
         // hide API link
         $("#li_api").hide();
       }
       else {
         $("#li_api").show();
       }

      });
   </script>


<script src="/rexify-website/public/js/skin/rexify.org/browser.js"></script>
<script>
  hljs.tabReplace = '    ';
//  hljs.initHighlighting();
  hljs.initHighlightingOnLoad();
</script>


   </body>

</html>
